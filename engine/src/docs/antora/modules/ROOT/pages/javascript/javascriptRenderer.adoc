= Javascript renderer
:page-pagination:

== General

Thanks to GraalVM we can now execute any JS script from within Java.

Javascript renderer takes advantage of that and enables you to generate HTML in Javascript using your favourite templating engine including but limited to React.

Markuply does not care what engine is used as long as it can be executed on the server ie. it does not use browser specific objects like `window` or `document`.

The only requirement is to define a global function named `render` that accepts two arguments: `viewName` and `props`. Where `viewName` is an identifier of the component to render (can be different than the Java counterpart) and `props` contain JSON representing view model generated by the component Java class.

[source,jsx harmony]
----
function render(viewName, props) {

  let person = JSON.parse(props);

  if (viewName === 'hello') {
    return `<div>Hello ${person.name}!</div>`;
  } else {
    return '';
  } 

}
----

React version will look a bit like this.

[source,javascript]
----
function render(viewName, props) {

  let parsedProps = JSON.parse(props);

  if (viewName === 'hello') {
    // JSX can be present in source files but the final script must contain the React.createElement equivalent
    return ReactDOMServer.renderToString(React.createElement(HelloComponent, parsedProps));
  } else {
    return '';
  } 

}
----

If you're using webpack remember to make the render function globally visible.

[source,javascript]
----
global.render = (viewName, props) => {
  // details omitted
};
----

And while we're at the topic of webpack there's nothing stopping you from using React together with Typescript. 

== Bean definition

There is no renderer defined by default so you have to provide one yourself.

Example below shows how to create a renderer loading the script file from external server.

.SpringConfiguration.java
[source,java]
----
@Bean
JavascriptRenderer provideJavascriptRenderer(WebClient webClient, ObjectMapper mapper) {
  return JavascriptRendererConfigurator.instance()
      .objectMapper(mapper)
      .externalScript(builder -> builder
          .webClient(webClient)
          .uri("http://localhost:3000/bundle.js"))
      .buildDevelopment();
}
----

.application.properties alternative
[source,properties]
----
markuply.javascript.bundle=http://localhost:3000/bundle.js
----

.application.yml alternative
[source,yaml]
----
markuply:
  javascript:
    bundle: "http://localhost:3000/bundle.js"
----

With this the renderer is ready to be invoked within component classes.

== Development and production

There are two special methods for configuring Javascript renderer for development and production purposes.

`.buildProduction()` focuses on performance and should be used on the target environment where the script won't change between server restarts.

`.buildDevelopment()` will create a renderer that will cache the script for 100ms (a single) and recompile the script only if it changes.
These settings facilitate development but do not expect the best performance.

It can also be controlled with the `markuply.javascript.production` property. By default it is set to false.
In this case Spring properties profiles come in handy. 
It is best to override this property in application-production.properties file and activate the production profile
only on the production environement.

== Renderer usage

To use the renderer just call the render method inside your component.

.HelloComponent.java
[source,java]
----
@Component
public class HelloComponent {

  private static final String JS_VIEW_NAME = "hello";

  private final JavascriptRenderer renderer;
  
  public HelloComponent(JavascriptRenderer renderer) {
    this.renderer = renderer;
  }

  @Markuply("hello")
  public Mono<String> renderHelloComponent(@Props String name, PageContext context) {
    HelloViewModel viewModel = HelloViewModel.of(name);
    return renderer.render(JS_VIEW_NAME, viewModel);
  }

}
----

== Rapid development

The development mode can be combined with webpack-dev-server to enable smooth development of frontend related aspects with no restarts.
For more details check xref:javascript/javascriptRapidDevelopment.adoc[].
